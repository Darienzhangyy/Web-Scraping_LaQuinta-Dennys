---
title: "hw2"
output: pdf_document
---



**get_lq.R**

This document implements procedures to download websites of LaQuinta hotels that primarity operates in the United States and store those links into directory "data/lq/". We extract websites of those hotels by creating a function named 'scrape_list' that it has the following functionalty: (1) matching US state names from csv file to US state abbreviations on website to identify American hotels; (2) extracting country/state abbreviations and replace NA with "NA""; (3) extracting the indexes from `rows` corresponding to the first entry after the US label and before the Mexico label; (4) extracting the indexes from `rows` corresponding to the state abbreviations; (5) extracting the indexes from `rows` immediately following the state abbreviations and corresponding to all American hotels; (6) extracting the links from the nodes indexed by `state_rows`and return those links. Finally we implement the 'html_download' function to download those links that are extracted by 'Scrape_list' and store them into directory "data/lq/". \newline

  
\quad\newline

**parse_lq.R**

This documents primary parses LaQuinta's hotel information of "name", "address", "phone", "fax", "latitude", "longtitude", "amenities", and "details" and store them as lq.Rdata in the "data/" directory. We first create a function named 'scrape_hotel' that it takes input as 'page' <full html file for a particular La Quinta hotel's webpage>, and returns output which is a list of 8 character vectors as above. After obtaining  the relative information, we then (1) check hotel names and addresses by visual inspection; (2) check hotel phone numbers by adherence to "1-xxx-xxx-xxxx" pattern and correct as needed; (3) replace " " with "-" corrects all flaws; (4) check hotel fax numbers by adherence to "1-xxx-xxx-xxxx" pattern and correct as needed; (5) replace " " with "-" corrects most - but not all - flaws; (6) insert "-" in the last seven digits corrects one more flaw; (7) trim leading zeroes corrects one more flaw; (8) convert three remaining flaws involve missing data to NAs;(9) check hotel names, addresses, hotel amenities, details correct and consistent as needed;(10) define and call a function to standardize hotel details and store those information into 'data/' directory. 

The constructed data frame has the following column names:
   
   (1) name, the name of the hotel;

   (2) address, the address of the hotel;

   (3) phone, the phone number of the hotel;

   (4) fax, the fax number of the hotel;

   (5) latitude, the latitude of the hotel location;

   (6) longitude, the longitude of the hotel location;

   (7) amenities, the features of the hotel and the room;

   (8) details, the hotel details (# rooms, floors, etc.). \newline


\quad\newline

**get_dannys.R**

This document implements steps to download xml data from the Where2GetIt API and store them into 'data/dennys/' directory. We first implement a function named query_api that it takes input as 'coordinate' <a data frame row containing a longitude, a latitude, and a search radius>, 'key' (default=api_key) <a valid API key allowing data scraping>, and 'limit' (default=1000) <an upper bound for the number of search results returned>. It then returns an output of XML file containing the results of the API query that is downloaded to disk. Finally we run query_api on the rows of the 'dennys_coords.csv' data frame to download XML files containing Dennys locations.\newline


\quad\newline

**parse_dannys.R**

This documents parse denny's stores data and stores corresponding information as 'dennys.Rdata' in the 'data/' directory. We implement the procedures by (1) letting R read in xml file to a list;(2) creating a logical vector for subsetting the unique store ID numbers;(3) extracting the results nodes for the unique Dennys locations;(4) creating a function named scrape_tag() that it takes inputs 'tag' <a particular xml tag whose value is to be extracted>, and 'result'<a particular result node>, and returns an output that contains the value of the xml tag. We also create a function named scrape_dennys() that it takes input 'result' <a particular result node> and returns output as a character vector with five elements:
            
            (1) clientkey, a unique store ID;
            
            (2) address, the address of the Dennys location;
            
            (3) phone, the phone number of the Dennys location;
            
            (4) latitude, the latitude of the Dennys location;
      
            (5) longitude, the longitude of the Dennys location.
           
We then extract the relevant information from the search results into a data frame, subset the data frame to include only US locations (those with a state abbreviation and ZIP code) and store them into 'data/' directory. \newline

\quad\newline



**Distance Analysis**


We calculate and aggregate the paired distances between LaQuinta and Denny's in different locations according to divisions of congressional districts, US disctrict courts and states. We first calculate paired distances using haversine formula and store the distance results into stateDistance.Rdata in '/data/' directory. We also visualize the number of LaQuinta and Denny's in each state and their corresponding distances in each state. The link to the visualization is here:http://rpubs.com/Darien/117132 



```{r, echo=TRUE}
load(dennys.Rdata)
load(lq.Rdata)

#create a function named format_coords that stores lqd_distance
format_coords = function(row, data.1, data.2) {
  lqd_distance = cbind(data.1[row[,1],,drop=F], data.2[row[,2],,drop=F])
  colnames(lqd_distance) = c('id1', 'lat1', 'lon1', 'id2', 'lat2', 'lon2')
  return(lqd_distance)
}

#calculate distance pairs using haversine formula
haversine = function(row, metric=F) {
  # Check that aspace package is installed and install if necessary.
  if(!('aspace' %in% installed.packages()[,'Package'])) {
    install.packages('aspace', repos='http://cran.rstudio.com/') 
  }
  require(aspace)
  
  # Provide output in kilometers if directed.
  if(metric) {
    radius = 6378.1
  } else {
    radius = 3963.17
  }
  
  #Implement the haversine formula with degree-based input.
  a = sin_d((row$lat1 - row$lat2)/2)^2 + 
    cos_d(row$lat1) * cos_d(row$lat2) * 
    sin_d((row$lon1 - row$lon2)/2)^2
  distance = 2 * atan2(sqrt(a), sqrt(1 - a)) * radius
}

get_coords = function(value, var=variable) {
  lq_lat = hotel_info$latitude[which(hotel_info[,var]==value)] %>% as.numeric
  lq_lon = hotel_info$longitude[which(hotel_info[,var]==value)] %>% as.numeric
  d_lat = dennys_info$latitude[which(dennys_info[,var]==value)] %>% as.numeric
  d_lon = dennys_info$longitude[which(dennys_info[,var]==value)] %>% as.numeric
  la_quinta = cbind(id=seq(length(lq_lat)), latitude=lq_lat, longitude=lq_lon) %>% as.data.frame
  dennys = cbind(id=seq(length(d_lat)), latitude=d_lat, longitude=d_lon) %>% as.data.frame
  indexes = expand.grid(la_quinta$id, dennys$id)
  coords = adply(indexes, 1, format_coords, data.1=la_quinta, data.2=dennys)
  out = adply(coords, 1, haversine) %>% .[,c('id1', 'id2', 'V1')]
  colnames(out) = c('lq_id', 'd_id', 'distance')
  return(out)
}

#Create a dataframe called distances_by_clusters 
distances_by_cluster = function(variable, data1=hotel_info, data2=dennys_info) {
  stopifnot(variable %in% colnames(data1) & variable %in% colnames(data2))
  clusters = intersect(unique(data1[,variable]), unique(data2[,variable])) %>% as.list
  coords = llply(clusters, get_coords, var=variable)
  names(coords) = clusters
  out = ldply(coords, function(value) { summary(value$distance) } )
  out = out[order(out$.id),]
  colnames(out)[1] = variable
  return(out)
}

#court_distances stores paired distances according to district courts
court_distances = distances_by_cluster('court')
#cd_distances stores paired distances according to congressional districts
cd_distances = distances_by_cluster('district')
#party_distances stores distance info according different parties
party_distances = distances_by_cluster('party')

save(file='data/distance_data.Rdata', list=c('court_distances', 'cd_distances', 'party_distances'))
```

\quad\newline
Caculate distances of LaQuita and Denny's and visulize the results:

```{r,results='asis',warning=FALSE}
suppressPackageStartupMessages(library(googleVis))
op=options(gvis.plot.tag='chart')
library(stringr)

load("./data/LaQuinta.RData")
load("./data/dennys.Rdata")
load("./data/Lq.RData")
load("./data/stateDistance.RData")
download.file("http://www.downloadexcelfiles.com/sites/default/files/docs/list-states-us-36j.csv",destfile = "./data/Statepop.csv")
Statepop=read.csv("/Users/YY/Documents/DUKE/Courses/2015Fall/STA523/HWs/HW2/Darien/data/Statepop.csv",skip=1,header = TRUE)
Statepop=Statepop[-1,]
Statepop=head(Statepop,50)
row.names(Statepop) <- c(1:50)
Statepop=Statepop[,-1]
Statepop$Population.est.=gsub(",", "", Statepop$Population.est., fixed = TRUE)

#Number of La Quinta in every state
dataLQ <- data.frame(LaQuinta)
Statecount=as.data.frame(lapply(dataLQ, table)$State)
names(Statecount)=c("Abbr.","LaQuinta")
Statecount = merge(Statecount, Statepop, by = 'Abbr.')
Statecount$LQpcapita=Statecount$LaQuinta/as.numeric(Statecount$Population.est.)

#Total number within states
Lq1 = gvisGeoChart(Statecount, locationvar='State', colorvar='LaQuinta',
                   options=list(region='US',displayMode="regions",
                   resolution="provinces",colorAxis="{colors:['yellow'
                   ,'red']}",backgroundColor="cornflowerblue",
                   width=700, height=430))
plot(Lq1)

#Per capita number within states
Lq2 = gvisGeoChart(Statecount, locationvar='State', colorvar='LQpcapita',
                  options=list(region='US',displayMode="regions",
                  resolution="provinces",colorAxis="{colors: ['yellow'
                  ,'red']}", backgroundColor="cornflowerblue",width=700,
                  height=430))
plot(Lq2)

########################################################

#Number of Denny's in every state
dataDen = data.frame(dennys_info)
#get the last split in address, unlist it to get a vector
DenState = unlist(lapply(str_split(dataDen$address, ", "), function(x) x[length(x)]))
#split the blanks
DenState = unlist(lapply(str_split(DenState, " "), function(x) x[1]))
#get the state count of Denny's
DenState = as.data.frame(lapply(as.data.frame(DenState), table))
names(DenState)=c("Abbr.","Dennys")
DenState = merge(DenState, Statepop, by = 'Abbr.')
DenState$Dennyspcapita=DenState$Dennys/as.numeric(DenState$Population.est.)
#latlong<-paste(dataDen$latitude, dataDen$longitude, sep=":")

#Total number within states
Den1 = gvisGeoChart(DenState, locationvar='State', colorvar='Dennys',
                     options=list(region="US",displayMode="regions",
                     resolution="provinces",colorAxis="{colors:['yellow'
                     ,'red']}",backgroundColor="cornflowerblue",width=700,
                     height=430))
plot(Den1)

#Per capita number within states
Den2 = gvisGeoChart(DenState, locationvar='State', colorvar='Dennyspcapita',
                    options=list(region="US",displayMode="regions",
                    resolution="provinces",colorAxis="{colors:['yellow'
                    ,'red']}", backgroundColor="cornflowerblue",width=700,
                    height=430))
plot(Den2)


library(rworldmap)
newmap <- getMap(resolution = "low")
#Positions of LaQuinta
plot(newmap, xlim = c(-125, -60), ylim = c(25, 45), asp = 1.5)
points(dennys_info$longitude, dennys_info$latitude, col = "red", cex = .6)
#Positions of Denny's
plot(newmap, xlim = c(-125, -60), ylim = c(25, 45), asp = 1.5)
points(hotel_info$longitude, hotel_info$latitude, col = "blue", cex = .6)
#Position of LaQuinta & Denny's
plot(newmap, xlim = c(-125, -60), ylim = c(25, 45), asp = 1.5)
points(dennys_info$longitude, dennys_info$latitude, col = "red", cex = .6)
points(hotel_info$longitude, hotel_info$latitude, col = "blue", cex = .6)

#Mean distance of LaQuinta & Denny's within every state
Dis = gvisGeoChart(stateDistance, locationvar='cluster', colorvar='Median',
                    options=list(region="US",displayMode="regions",
                    resolution="provinces",colorAxis="{colors:['yellow'
                    ,'red']}", backgroundColor="cornflowerblue",width=700,
                    height=430))
plot(Dis)
```





